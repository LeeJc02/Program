# 基础预备知识

### 一、问题解法的效率

#### 			1.数据结构的选择：逻辑结构（抽象数据结构）/内存结构

##### 							描述数据结构：抽象数据类型---即将数据的对象集/操作集，进行抽象化

##### 							数据类型：数据对象集和对象操作集

###### 				（对象集/操作集：C语言中操作与数据对象分开，而C++中提供类进行合二为一）

##### 					        抽象：与自身类型无关，抽象为简单化、本质化、易于建模的一种类型

#### 			2.空间的利用率

##### 					        递归：占内存，N遍递归调用则连开N个函数的内存空间

#### 			3.算法的选择：T(N)/S(N) ----------> O(N)复杂度

### 二、时间与复杂度

#### 			1.时间（用time.h）

##### 							-  运行的时间以clock tick为单位【时钟打点】

##### 						    -  以clock()函数返回的为一个clock_t类型的变量

##### 						    -  CLK_TCK为系统时钟打点常数【即clock tick缩写】

##### 						    -  (double)(stop-start)/CLK_TCK得到stop和start之间运行的时间

#### 			2.复杂度

##### 							-  时间复杂度T(n)：即所运行语句跟n的直接关系

###### 										1.同时有加减乘除求余运算时，忽略+ -不计，只算* / %

###### 										2.pow(x,i)，实际上运算i-1次

###### 										3.拥有Tworst(N)>=Tavg(N)，通常只研究Tworst(N)

##### 							-  空间复杂度S(n)：即所开内存跟n的直接关系（一般空间复杂度为常量）

#### 			3.复杂度渐进表达（以T(N)为例，S(N)同理）

##### 							-  T(N)=O(f(N))，存在常数C>0，n>0，即有T(N)<=f(N)

###### 										即O(f(N))为T(N)的上界，一般只取最小上界，即3n^2+n只取O(n^2)

##### 							-  T(N)=Ω(f(N))，存在常数C>0，n>0，即有T(N)<=f(N)

###### 										即Ω(f(N))为T(N)的下界，一般只取最大下界

##### 							-  O(1)<O(log(n))<O(n)<O(n*log(n))<O(n^2)|<O(n^3)<O(2^n)<O(n!)

###### 										不考虑|以后的复杂度，n^2需要尽可能想办法转化为n*log(n)

##### 							-  不同结构的复杂度选择不同：

##### 										1.循环：复杂度相乘

##### 										2.顺序：复杂度取最高

##### 										3.选择：复杂度取最高



# 线性结构（C语言版）

## 		一、线性表（linear list）

#### 				1.一元多项式表达：（ai*x^i，需要存储ai和i两个数据）

##### 								-  数组：数组下标对应i，a[i]对应ai【不方便计算，浪费空间】

##### 								-  结构数组：将（ai，i）看作一个二元组的集合，对应一个非零项

##### 								-  链表：一个节点储存ai，i和next指针，将非零项链接起来

#### 				2.线性表：同类数据元素，有序线性序列

##### 								-  以Struct定义的结构体为节点（元素之间共存）

##### 								-  长度、表头、表尾、空表

##### 								-  链表的【动态申请、初始化、查找、插入、删除】（见C++笔记）

#### 				3.广义表（generalized list）

##### 								-  以Union定义的共用体为节点（元素之间相互覆盖）

##### 								-  线性表的推广（如二元多项式）

##### 								-  元素不仅可以是单元素，也可以是另一个广义表（分支结构）

#### 				4.多重链表：

##### 								-  某节点可能同时属于多条链，即指针可能有多个，指向不同节点

##### 								-  多个指针指向不同节点不一定是多重链表【双向链表】

##### 								-  稀疏矩阵、树、图的各种存储和运用

## 二、堆栈（stack）0/多个元素的有穷线性表

#### 1.计算机运算（后缀表达式 --- 区别于平时用的中缀表达式）

##### -  从左到右读入，从右到左取出进行运算

##### -  以堆栈的形式输入输出，即栈的【先入后出，后入先出】（last in first out	LIFO结构）

##### -  堆栈使用：正序输入，逆序输出

##### -  入栈（push）	出栈（pop）	栈顶（top）	仅可在栈顶进行插入、删除操作

#### 2.数组实现堆栈：

##### 			-  以一维数组和记录栈顶位置的变量Top组成堆栈，Top=-1为空栈，Top=length-1为栈满

##### 			-   push入栈：栈满返回，在非栈满情况下，入栈数据给arr[++Top]

##### 			-   pop出战：空栈返回，在非空栈情况下，出栈数据为arr[Top--]

##### 			-  一个数组实现两个堆栈：

###### 					1. push入栈：以数组两端为栈底，同时在中间数组入栈【即共享可入栈的空间】

###### 	（ Top1=-1时栈堆1为空栈，Top2=length时堆栈2为空栈，Top2-Top1==1为栈满【相邻】）

###### 					2.   pop出栈：同时判断Top1，Top2是否为-1/length，即判断是否为空栈

#### 3.链表实现栈堆：

##### 			-  以表头为栈顶Top，表尾为栈底（表尾删除无法找到前一个节点）

##### 			-  为方便入栈、出栈，head头指针改为一个头节点，该头节点不表示一个元素

##### 			-  头节点的后一个节点为栈顶Top，头节点next==NULL时，为空栈

##### 			-  入栈操作，即将节点插入进头节点和Top节点之间，出栈相同【切记释放内存】

##### 			-  在入栈操作中，数组固定有栈的长度需要判定是否满栈，链表则需要新申请内存，不需要判断满栈

#### 4.再谈运算（中缀表达式转化为后缀表达式）

##### -  转化原理：遇到数字先输出，遇到符号先存储（该存储即为堆栈）

##### -  若运算符优先级>=栈顶运算符，则该运算符入栈，原栈顶运算发压栈

##### -  若运算符优先级<栈顶运算符，则栈顶运算符出栈，直到栈顶运算符优先级>=该运算符 

##### -  存在括号："("以优先级最高压栈进入，进入后优先级变为最低，")"一直出栈直到遇到"("

###### （括号出栈后不输出在后缀表达式中）

#### 5.栈堆的引用（调用后恢复原来的状态）

##### -  函数调用及递归

##### -  DFS：深入优先搜索

- ###### DFS路径问题，标记路径数组的长度，在不同的岔路口，通过已标记传参的长度对不同路径进行覆写，实现不同路径问题，可用另一数组/整数来记录不同路径，每条路径达到要求进行对比替换（最小路径/最合适路径）

##### -  回溯算法

## 三、队列（queue）

#### 1.区别堆栈

##### -  堆栈：入栈push，出栈pop					队列：入队front，出队rear

##### -  堆栈：在Top处进行出栈入栈操作			队列：在front入队，在rear出队

##### -  堆栈：LIFO												队列：FIFO

#### 2.实现队列

##### -  两个栈实现队列（偶个数栈实现队列）：偶数次逆序，成为顺序，队列容量为所有栈容量总和

##### -  顺环数组（以数组下标求余得到数组顺环）：

###### 1. front = rear = -1时，建立空队列，size=0为元素个数

###### 2. front = rear判断空队，则只能储存MAXSIZE-1个元素，size = 0判断空队，则可储存MAXSIZE个

###### 3.防止一端入队一端出队后空间浪费

##### -  链表实现队列：头节点为front，尾节点为rear（即在表尾插入，表头删除）

###### （ 注意尾结点指针指向NULL，临时节点的创建和释放 ）

#### 3.多项式加法：

##### -  数组：下标为指数，存储为系数，系数为0不输出（指数相差不大，非稀疏，用于固定大小长度）

##### -  链表：指数降序进行链接，实现插入或修改操作（万能且麻烦，不限长度）

#### 4.多项式乘法：

##### -  n项和m项多项式乘法，得n*m个项，再进行同类项合并

##### -  n个多项式相加（即n项里面每一项和m所有项相乘，得n个多次项）



# 树结构（Tree）

## 一、基本的树

### 1.概念：

##### -  树(Tree)：n(n>=0)个节点(node)构成的有限集合 ---> n为0时为空树

##### -  深度(depth)：自顶向下，到根节点距离

##### -  高度(height)：自底向下，到叶节点距离

##### -  根节点(root)		  叶节点(leaf)：无子节点		  子节点(child)/父节点(parent)/兄弟节点(sibling)

##### -  边(edge)				权重(weight)							层次(layer/level)

##### -  度(degree)：子节点的个数									 树的度：节点的最大度

### 2.特性：

##### -  树的条件：①连通	②边数=节点数-1

##### -  子树之间互不相交，不形成闭环

##### -  可实现将问题抽象为树，在进行DFS/BFS

### 3.树的表示：

##### -  以最大度设置结构体中的指针数，占用指针域为n*degree（内存的话需要degree+1），只有n-1未被浪费

##### -  儿子-兄弟表示法 ---> 二叉树

##### -  一般树的先根遍历 == 二叉树的先序遍历，共有层序遍历

## 二、二叉树(binary tree)

### 1.基本二叉树：

##### -  二叉树和度为2的树异同：

###### ①二叉树是度为2的树，度为2的树不一定是满二叉树

###### ②二叉树有左右子树之分，存在同构，度为2的树左右倒换表示同一棵树

##### -  第i层最多有2^(i-1)个节点，一共最多有2^i-1个节点

##### -  非空二叉树：n(leaf)==n(degree=2)+1 （对边的贡献进行证明）

##### -  深度为d，只有度数为0/2的节点，则该二叉树节点数>=2*d-1

### 2.完全二叉树(complete binary tree) ---> 包含了满二叉树

##### -  满二叉树：每个节点的度都为2

##### -  完全二叉树：n-1层为满二叉树，最后一层节点连续且集中在左边

###### 满二叉树是完全二叉树，完全二叉树不一定是满二叉树

##### -  以数组实现极其方便，以层次遍历进行编号

- ###### 编号为i，左子树为i×2，右子树为i×2+1

- ###### 编号为i，父节点为i/2，向下取整

- ###### 若子节点超出最大节点数，则该子节点不存在

### 3.静态链表实现二叉树

##### -  链表的节点结构：①节点编号/权重/层级   ②左子树指针/右子树指针

##### -  遍历：先/中/后序(preorder/inorder/postorder)遍历和层级遍历

- ###### 先/中/后：深度优先，路径相同，根左右/左根右/左右根进行输出，根分别遍历1/2/3次输出，可用栈实现

- ###### 层级遍历：广度优先，一层一层进行访问

- ###### 遍历核心思想：将二维结构转化为线性访问

  ##### -  插入时，先找到叶节点，并修改叶节点的左右指针（传入节点指针时，需要加&引用，否则无法修改指针）

  ##### -  求二叉树高度：即递归求每个小的二叉树的高度，直到空树为0，返回时为左右二叉树最大值加一

  ##### -  二元运算表达树：

  - ###### 数放在叶节点，运算符放在根节点，后续遍历得到后缀表达式

  - ###### 中序遍历得到中缀表达式，但不准确，需要每一个小的二叉树加一个括号

  ##### -  中序遍历+先序/后序，可还原一整个树

  - ###### 先序/后序找到根节点，再通过中序确定左右子树节点个数

  - ###### 递归左右子树在序列中存在的某一段，重新找子树根节点

  - ###### 子树的根节点递推返回，赋值给根节点的左右节点指针

### 4.结构体数组实现二叉树

##### -  数组的节点结构：①节点编号/权重/层级   ②左子树/右子树的数组下标，不存在则-1

##### -  在整个数组里面某一个数root未在任何左子树/右子树数组下标中出现，则root为根节点

##### -  判定两个二叉树是否同构：Judge(int a,in b)，将两棵树的根节点传入

```c++
bool Judge(int a,int b){	//即分六种情况分别递归或直接判定
    if(a == -1 && b == -1)	
        return true;	//根节点都为空，则同构
    if(a == -1 && b != -1 || a != -1 && b == -1)	
        return false;	//根节点一个为空，则不同构
    if(T1[a].value != T2[b].value)	
        return false;	//都不为空时，值不相等，则不同构
    if(T1[a].left == -1 && T2[b].left == -1)
        return Judge( T1[a].right,T2[b].right );	//左子树都为空时，判定两个右子树是否为空
    if(T1[a].left!= -1 && T2[b].left != -1 && T1[T1[a].left].value==T1[T1[a].left].value)
        return Judge(T1[a].left,T2[b].left) && Judge(T1[a].right,T2[b].right);
    	//左子树都不为空时，如果左子树根节点的值相同，则分别判定两个左子树和右子树是否同构
    else	return Judge(T1[a].right,T2[b].left) && Judge(T1[a].left,T2[b].right);
    	//在上一个if的条件下，如果左子树根节点值不相同，则判定左/右，右/左是否同构
}
```

##### -  同样适用于一般树的静态实现

```c++
struct node{
    typename data;	//若不涉及到数据域，则简写为vector<int> child[maxn]，邻接表实现
    vector<int> child; //自由长度存放不同个数的子节点，不浪费空间
}Node[maxn];
```

## 三、二叉搜索树(BST)

### 1.基本特征

##### - 任意左子树任何节点都比右子树任何节点小

##### - 同一序列以不同顺序插入BST得到不同的树

##### - 对二叉搜索树进行中序遍历是有序的（同一序列不同插入也能得到一样的中序序列）

##### - 搜索树的查找效率为树的高度，尽量使得树又矮又宽（平衡树）

### 2.基本操作

##### - 查找：参照二分查找

##### - 插入：根据二分查找，查找到某个叶节点时进行插入

##### - 建树：新建节点并进行插入

##### - 删除：

###### · 根节点为空则退出，否则则进行查找需要删除的节点

###### · 查找到节点则删除该节点，若存在左子树则以左子树前驱（即左子树最右边的左子树最大值）替代

###### · 若无左子树有右子树则以右子树后继（即右子树最左边的右子树最小值）替代

###### · 递归直到前驱/后继为叶结点时结束

### 3.镜像树

##### - 二叉搜索树的镜像树，即所有左右子树相互交换得到的镜像

##### - 二叉搜索树的中序遍历为升序的序列------镜像树中序遍历为降序的序列

##### - 二叉搜索树的先序/中序遍历 与 镜像树的先序/中序遍历互为逆向序列

## 四、二叉平衡树(AVL)

### 1.基本特性

##### - AVL树本质上还是二叉查找树，又称之为二叉平衡查找树，是BST的优化

##### - AVL通过降低二叉搜索树的高度，使之达到平衡并降低搜索的时间复杂度

##### - 平衡因子BF=h(左子树高度)-h(右子树高度)

##### - 任意节点的|BF|≤1的二叉搜索树，则为二叉平衡树

### 2.平衡操作

##### 1.左旋：即逆时针旋转，根节点的右子节点连接右子树的左子节点，根节点变为右子节点的左子节点

##### 2.右旋，即顺时针旋转，根节点的左子节点连接左子树的右子节点，根节点变为左子节点g的右子节点

##### 3.左/右旋互为逆操作，左/右旋的过程中需要重新更新两个节点（根节点和左旋右子节点/右旋左子节点）的高度

##### 4.树的类型：	【左正右负】

###### · LL型：插入节点后某一节点BF为2（L），其左子节点的BF为1（L）	

###### · LR型：插入节点后某一结点BF为2（L），其左子节点的BF为-1（R）

###### · RL型：插入节点后某一节点BF为-2（R），其右子节点的BF为1（L）

###### · RR型：插入节点后某一结点BF为-2（R），其右子节点的BF为-1（R）

注：LL与RR对称，RL与LR对称

##### 5.树的操作：

###### · LL型：以BF为2的根节点进行左旋

###### · LR型：以BF为-1的左子节点进行右旋，变化成LL型，再以BF为2的根节点进行左旋

###### · RL型：以BF为1的右子节点进行右旋，变化成RR型，再以BF为-2的根节点进行右旋

###### · RR型：以BF为-2的根节点进行右旋

### 3.基本操作

##### - 计算每个节点的BF：

###### · 将每个节点的高度存入节点的结构体中（自下而上，在建树插入过程进行存值）

###### · 设计一个函数用于计算该节点的BF，即左子树的高度-右子树高度

###### · 若某一个节点为2/-2，则进行左旋/右旋操作

##### - 查找：同二叉查找树（删除太难没有学）

##### - 插入：在二叉查找树的基础上，递归返回时（即递归子节点的语句下）判定当前根节点是否BF为±2，                         			  再根据正负判定左/右子节点的正负，确定树的类型，进行树的左/右旋操作

## 五、堆（Heap）

### 1.基本特性

##### - 堆是一个完全二叉树，常用数组实现，左子节点下标为n×2，右子节点下标为n×2+1（超出则无），父节点为n/2

##### - 堆分为大顶堆/小顶堆，即根节点一定大于/小于子节点，但两个子节点之间无法明确大小

##### - 堆作为完全二叉树，同样有完全二叉树的性质，如叶节点的个数为ceil(n/2)个，则非叶节点下标为[1,n/2]

### 2.基本操作

##### - 查找：即遍历数组

##### - 插入：续接到数组最后一位，再自底向上进行调整函数

##### - 删除：查找删除的元素，若是大顶堆最大值/小顶堆最小值，则对堆顶进行删除操作，对整个堆或者局部堆的堆顶进行删除，即将这个堆最后一个元素覆盖堆顶，删除最后一个元素，再自顶向下调整函数

##### - 建堆：①堆插入，即循环进行插入操作，自底向上，O(nlogn)

##### 			  ②堆排序，即从floor(n/2) -> 1（非叶子节点）进行调整函数，自顶向下，O(n)

##### - 调整函数：

```c++
void Adjust(int low,int n){ //low为当前下标，n为最后一个数下标
    int i=low,j=i*2;		//以i，j作为哨兵
    while(j<=n){			
        if(j+1<=n && heap[j+1]>heap[j])//表明以j代表左右节点最大的下标
            j++;
        if(heap[j]>heap[i]){		  //若此时子节点中最大值大于堆顶，则进行数值交换
            swap(heap[i],heap[j]);
            i=j;					  //原先的heap[low]的值变到了j的位置，j再次当作左子节点
            j*=2;					  //如果左子节点超过了n，即这个时候的i为叶节点，则不循环
        } else	break;			//如果这个时候在堆顶已经大于了左右子堆堆顶最大值，则不需要再调整
    }
}//自顶向下，与子堆最大值进行交换，直到变为叶节点结束，O(logn)
```

## 六、哈夫曼树（最优二叉树）

### 1.哈夫曼树

##### - 带权路径长度WPL：即nΣ(i=1)(Wi*Pi)，表示所有叶节点权值×路径长度之和

##### - 哈夫曼树（WPL最小）：优先合并最小的两个叶节点，权重之和为根节点，并且根节点权重放入，再进行去最小的两个合并，直到合并完全

##### - 哈夫曼树的结构可能不唯一，但是WPL的最小值一定唯一

##### - 先合并最大的两个叶节点则得最大WPL

##### - 常用堆的应用，即priority_queue优先队列，找到每次进队后的最大元素，并合并后入队（自动排序）

### 2.哈夫曼编码（哈夫曼树不唯一，哈夫曼编码也不唯一）

##### - 前缀码：任何节点0/1编码不会成为其他任何绩点编码的前缀

##### - 需要确定字符，以及字符出现的频率

##### - 以每个需要编码的字符的出现次数为叶节点权重，该字符为叶节点

##### - 建哈夫曼树，左0右1，从根节点到叶节点的路径即为前缀码，实际长度即为WPL

## 七、并查集

### 1.概念：

##### - 合并（Union）、查找（Find）、集合（Set）

##### - 同一个集合只存在一个根节点，作为这一个集合的标志

##### - 以一个数组实现，下标为元素值或序号，值为父节点，根节点的值为负数，数字表示这个集合有多少元素

##### - 只由根节点进行操作，保证同一集合中不会形成环，即保证结构为一棵树

### 2.基本操作

##### - 查找：递归找到根节点，明确是属于哪个集合

##### - 合并：两元素合并，判定是否为同一集合，即分别找到根节点是否相同，如果不相同则合并，元素少的挂在元素多的上，这样避免树的高度太高增加时间复杂度，并同时修改两个根节点的值

### 3.路径压缩

##### - 降低树的高度从而减少时间复杂度

##### - 遍历集合，将除根节点外所有节点都指向根节点，查找节点的时间复杂度降为O(1)