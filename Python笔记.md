```python
`python进制转化：【以字符串形式储存】
    bin()：转化为二进制【其他C++可用，bin不可用】 
    otc()：转化为八进制 
    hex()：转化为十六进制
以enumerate，对【可遍历的结构】同时获得索引和值
字符串控制符：【通用】
     r：字符串防止转义
     f：解析字符串中任意类型
ESC符号控制：【其他语言通用】 
    【\033：八进制 \027：十进制 \x1b：十六进制】`
数字00默认为0
```

![a1d5eb52-ee07-4abf-96b5-ac726633eb1f](file:///C:/Users/86180/Pictures/Typedown/a1d5eb52-ee07-4abf-96b5-ac726633eb1f.png)

fp=open('C:/tast.text','a+')//a+表示读写，open打开一个file类对象，若无该文件则自动创建
print('helloword',file=fp)//输出进入这个file类的fp
fp.close()//关闭该文件

.upper()：全部字符大写                               【字符串为不可变序列，大小写转换产生新的字符串序列，ID改变】
.lower()：全部字符小写                                 【就算和原本相比未产生变化，ID也发生了改变】
.capitalize()：首字符大写，其余字符小写
.swapcase()：大写转小写，小写转大写
.title()：每个单词首字符大写

```python
0b表示二进制，0o表示八进制，0d表示十进制，0x表示十六进制
char（）：括号中如果是数字，默认十进制，前缀加上0b表示后面是二进制代码
ord（）：表示以十进制输出括号内的字符（汉字在UTF-8用三个字节，Unicode用两个字节）daxiao
```

```python
id（）：对象储存的内存地址
type（）：对象的数据类型 
数据类型：（1）：numbers数字：int long（与内存有关无上限） float（类比C中double） complex（复数）
        （2）：string字符串（str）：单引号双引号只能在一行，三引号可以多行显示字符串
        （3）：list列表：[]有序排列
        （4）：tuple元组：（）
        （5）：dictionary字典（dict）：{}不一定有序排列
        （6）：boolean布尔（bool）：true or false（None或者0或者各种为空的数据结构）
        （7）：set集合
```

```python
浮点数精确相加：导入decimal模块（不一定需要）
from decimol import Decimal
print（Decimal（'1.1'）+Decimal（'2.2'））
print中字符串不能和别的类型以'+'相连接，需要数据转换
str转int：str必须是整数字符串才能转（bool可转）   转float：str必须是数字字符串
```

```python
#为单行注释
'''为多行注释
#coding：UTF-8------->为中文编码声明
余数=被除数-除数*整数商（尤其是一正一负求余需要使用）
```

```python
a=b=c=20（链式赋值，内存地址相同）
a，b，c=20，30，40（a=20，b=30，c=40，解包赋值要求左右个数相等）
利用解包赋值进行数据交换：a，b=b，a
比较运算符的结果是bool类型（true or false）
==比较的是值        is比较的是内存地址（ID）
如果变量的值相同则ID相同，如果是完全相同的列表，则ID不同
布尔运算：and    or      not（bool结果取反）     in（表示前者属于后者一部分）         not in
```

```python
位运算（二进制）
按位与&：在某一位上同为1时结果为1，有0则0
按位或|：在某一位上同为0时结果为0，有1则1
左移位<<：高位溢出，低位补0（a<<1：变量a左移位1位，相当于*2）
右移位>>：高位补0，低位截断（相当于//2，整除）

括号------->算术运算------>位运算------>逻辑运算------->布尔运算------>赋值运算
```

```python
range(a,b,c):表示[a,b)步长为c，无a默认从0开始，无c默认步长为1       的一个列表

for in（while）与else搭配：循环没有运行break，则运行else，此时for in（while）和else同一级
```

```python
列表（一字排开，类比C中数组）：可混存各种类型/可重复存储相同数据/无内存溢出
列表的ID指向的是该列表地址，在该地址储存列表各数据的ID地址

索引： -7   -6  -5  -4  -3  -2  -1 【-n，0）
数据：数据1  2   3   4   5   6   7（共n个）
索引：  0    1   2   3   4   5   6 【0，n）

list=[i(列表元素表达式) for i in range(1,10)(列表元素生成式)]:要求列表元素有规律

.index（数据，a，b）：在【a，b）中查询非负索引数，有重复数据只返回第一个索引到的数据位置，查询不到则ValueError
                        无a和b时默认遍历查询
指定的数据位置索引在列表中不存在，则IndexError

列表的切片：list[start:stop:step]（冒号最好写出来）
索引在【start，stop），步长为step的数列中的数据切片出来
        step为正数时（默认为1）：start默认为0，stop默认为结尾数
        step为负数时（-1时逆序输出）：start默认为结尾数，stop默认为0

列表的元素增删改操作：（列表ID不变）                此时list作为一个列表数据
（一）：增加
    .append（）：列表末尾添加一个元素，如果添加的是列表则整体作为一个元素
    .extend（）：列表末尾至少添加一个元素，如果添加的是列表则该列表所有元素都添加到list
    .insert（a，b）：列表任意位置添加一个元素，a为索引位置，b为添加数据
    list[start:stop:step]=list2：将切片部分删去，以list2替换
（二）：减少
    .remove（）：列表删去一个元素，有重复数据只删去第一个索引到的数据位置，查询不到则ValueError
    .pop（）：列表任意位置删去一个元素，括号内为索引位置，无参数默认删除结尾元素，索引不存在则IndexError
    .clear()：清楚list的所有元素，括号内无参数
    list[start:stop:step]=[]：将切片部分删去
    del list：删除列表
（三）：修改
    单个数据修改：覆盖性赋值
    list[start:stop:step]=list2：将切片部分删去，以list2替换    

排序：
    .sort（）：升序排序，ID不变（默认reverse=False）        .sort（reverse=True）：降序排序，ID不变 
    内置函数list2=sorted（list）：原列表不变，生成一个升序新列表（默认reverse=False）        
```

```python
字典：（花括号直接创建，用内置函数dict（'A'=100,'B=85,'C'=65)进行赋值）
scores={'A':100,'B':85,'C':65}       'A'/'B'/'C':键   100/85/65:值----->键重复则覆盖赋值，值可以重复
可变序列---->可进行增删改操作
以键值对的方式储存数据------>无序序列，存储数据经过hash（键）函数进行排列，与输入顺序无关
    键作为字符串是不可变序列，整数也不可变
获取数据：
        scores['A']/scores.get['A']表示键A所对应的值（若查找键不存在，前者KeyError，后者None）
        scores.get['A',99]表示键A不存在时默认'A'的值为99
（一）：删除
    del scores['A']：删除'A'对应键值对
    .clear()：清空该字典
（二）：增加/修改
    scores['D']=98：增加'D':98这一个键值对，若存在'D'则对其的值进行重新赋值
（无法指定位置插入，字典排序是哈希值进行排序）

视图：
    .keys()：获取所有的键（type为dict_keys）
    .values()：获取所有的值（type为dict_value）
    .items()：获取所有的键值对（type为dict_items)------>每一对为一个元组 

字典遍历变量为键，以scores[变量]/scores.get[变量]表示遍历变量所对应的值
字典生成式：键列表list1    值列表list2------->两列表以元素少的为标准
    dict={i:j  for i,j in zip(list1,list2)}    （与集合生成式相比，需要内置函数zip进行打包）
```

```python
元组：（以小括号直接创建或者用tuple内置函数（外部括号表示参数，内部括号为元组括号）给元组变量进行赋值）
    只包含一个元素的适合，在括号里需要加一个逗号，不然默认非元组数据
不能对元组内数据进行ID上的改变                                            元组可进行遍历


集合：（以花括号直接创建或者set内置函数给集合变量进行赋值）--------->无重复元素，类型转化时自动去除重复元素
    与字典类似（以花括号表示，同样以哈希值【无序】进行排序），但只有键，没有值

（一）：增加（此时若添加列表/集合/元组，则将该数据结构拆开释放所包含所有元素）
    .add()：添加一个元素
    .update()：至少添加一个元素 
（二）：删除
    .remove()：删除一个元素，若集合中无该元素，则KeyErro    
    .discard()：删除一个元素，无该元素不报错
    .pop()：随机删除一个元素，括号里不能加参数
    .clear()：清空集合，无参数

集合的包含关系：
    a.issubset(b)：表示判断a是否为b的子集
    a.issuperset(b)：表示判断a是否为b的超集（即b是a的子集或二者相等）
    a.isdisjoint(b)：表示a与b是否没有交际（True表示没有交集）
求两集合之间的某部分：
    交集：.intersectiong()                                    （a & b）
    并集：.union()：                                          （a | b）
    集合a对交集的补集：a.difference(b)：a-（a & b）             （a - b）
    并集对交集的补集：.symmetric_difference()                   (a ^ b)

集合生成式：列表生成式的[]换成{}（没有元组生成式）
```

```python
可变序列：（list，dict）
    可在原有基础上进行增删改操作，对象地址不改变
不可变序列：（str，tuple，int）
    没有增删改操作，只有重新建立一个新的进行改变
无序数列：（dict，set）
    对键用hash函数，以哈希值进行排列，常无序
空列表/字典/元组/集合：
    lst=[] / lst=list()                dic={} / dic=dict()
    tu=()  / tu=tuple()                         se=set()：唯一一个不能直接括号直接创建空
```

```python
字符串的驻留：
    不同的标识符所表示同样的字符串（数字字母下划线所组成的符合标识符的字符串/[-5,256]的数字），则地址相同（IDE）
    Pycharm字符串优化，避免了频繁创建
字符串拼接尽量使用join函数，效率更高
```

```python
字符串查询：
    .index(str)：查找子串str在主串中第一次出现的位置（str首字符在主串的索引）查找不到返回IndexError
    .find(str)：                  第一次                                查找不到返回-1
    .rindex(str)：查找子串str在主串中最后一次出现的位置（str首字符在主串的索引）查找不到返回IndexError
    .rfind(str)：                  最后一次                                查找不到返回-1
```

```python
字符串的对齐：
    .center(a,b)：居中，a为指定宽度，b为剩余填充符（默认为空格）        a＜原字符串长度则返回原字符串
    .ljust(a,b)：左对齐，a为指定宽度，b为剩余填充符（默认为空格）        a＜原字符串长度则返回原字符串
    .rjust(a,b)：右对齐，a为指定宽度，b为剩余填充符（默认为空格）        a＜原字符串长度则返回原字符串
    .zfill(a)：右对齐，左边以0填充，a为指定宽度                        a＜原字符串长度则返回原字符串
```

```python
字符串的劈分：
    .split(a，b)：将字符串以a为界限从左到右进行劈分，不写默认为空格，返回值是一个列表
                  最多劈分b次，不写默认为最多次数
    .rsplit(a,b)：从右到左进行劈分
```

```python
字符串的各种类型判断：（bool判断）
    .isidentifier()：判断是否全是合法的标识符字符串
【以下类比C的ctype类函数】
    .isspace()：判断是否全为空白标识符字符串
    .isalpha()：判断是否全为字母字符串
    .isdecimal()：判断是否全为10进制数字字符串
    .isnumeric()：判断是否全为数字的字符串
    .isalnum()：判断是否全为字符和数字的字符串

注：汉字也归入字母一类
    汉字数字，大写汉字数字，罗马数字也归入数字一类
```

```python
字符串的替换和合并：
    s.replace(a,b,c)：用b来替换s中的a子串，最多换c次，c不写默认所有a都替换掉
    a.join(list/tuple/str)：将列表/元组/字符串中的每个元素以字符a为纽带，连接成字符串
```

```python
字符串的比较：（类比C中的strcmp字典序）
    依然用ASCII码进行一一比较（字符串直接以比较运算符比较）

字符串的切片：（类比列表的切片，需要一个新的字符串来储存切片内容）
```

```python
格式化字符串：【字符串不能修改，每次创建浪费空间，以格式化字符串避免浪费空间】
    （一）：'格式文本，里面以%加字母为占位符（类比C）' % （元组里面元素与前面占位符一一对应）
    （二）：'格式文本，以{}为占位符，里面可写数字作为索引，也可不写'.format(与前面一一对应）【注意是小数点】
            {0:10.3}表示索引为0，宽度为10，保留三位        {0:10.3f}保留三位小数     ------>四舍五入保留

编码与解码：（以什么类型编码编，就以什么类型编码解，否则报错）
    s.encode(encoding='GBK') -------->以GBK编码对s进行解析
    byte=s.encode(encoding='GBK') ---------->解析出来为字节类型
    print（byte.decode(encoding='GBK')） ----------->对byte字节进行解码
```

```python
函数：
    形参改变，实参不变，可变序列可在函数中进行增删改（ID不能变）
    返回值如果有多个值，以一个元组的形式返回

    个数可变的位置参数：【以（*a）定义形参表】【a的结果为一个元组】        fun（*list）将列表每个元素对应传参
    个数可变的关键字形参：【以（**a）定义参数表】【a的结果为一个字典】     fun（*dict）将字典每个元素对应传参
    如：def fun（**a):                     ------------> 此处只能有a一个参数
           print（a）
        fun（a=10）                        ------------> 结果为 {'a':10}
        fun（a=10，b=20，c=30）            ------------> 结果为 {'a':10,'b':20,'c':30}
    fun(*a1,**a2)成立        fun（**a1,*a2)报错       fun（a,*,b):*之后的只能用关键字传参

局部以global定义的变量为全局变量
```

```py
异常处理机制：
    try ：运行try内的语句是否有程序异常
        try中可用raise进行异常抛出，抛给except进行接收处理
    except <异常类型> ：如果异常，判断是该异常类型则运行此语句（无异常类型则所有异常都属此类）
        在except中对抛出进行接收并可对抛出语句重新当作报错信息，进行操作
    else ： 如果不异常，运行此语句
    finally ： 不管异常与否都运行
  try至少有一个except，else与finally可有可无
【try-raise-except类似于C++中try-throw-catch类型】
常见异常类型：
    ZeroDivisionError ：取模0或者被除数为0
    IndexError ：索引异常
    KeyError ：键异常，映射中无此键
    NameError ：未声明/初始化对象（没有属性）
    SyntaxError ：语法错误
    ValueError ：值异常/传入无效参数

traceback模块（import导入，pycharm自带）
    打印报错信息，traceback.print_exe（）函数            【打印问题 ---> 线程问题】
```

```python
python中的类：【self：类的一个实例对象    cls：类（或子类）本身】
    1.两大编程思想：
        面向过程编程
        面向对象编程（类）
    2.类（class）：一切皆对象
    3.类的组成：【以dir查询类对象/实例对象中的属性与方法】
        . 类属性
        · 实例方法
        · 静态方法
        · 类方法
    4.类的创建：
        class <类名>:
            #类属性
            <属性名> = '属性值' #可动态创建临时属性
            #创建类的实例对象
            def __init__(self,<>): #实例属性初始化
                (创建实例对象并传入参数，赋值创建给【实例属性】，self·<>为实例属性) 
            #实例方法
            def <函数名>(self,<>):
                (仅能由实例对象调用，可调用实例属性，类属性，也可使用时加入参数表)
            #静态方法
            @staticmethod #装饰器
            def <函数名>(<>):
                (可由类对象/实例对象调用，自身无法使用实例方法和属性)
            #类方法
            @classmethod
            def <函数名>(cls，<>):
                (可由类对象/实例对象调用，无法使用实例方法和属性，一般校验工作使用类方法)
    动态绑定：
        动态绑定属性：<实例对象名>.<动态属性名> = '属性值'    #该属性只用于该实例对象
        动态绑定方法：<实例对象名>.<动态方法名> = <已定义的函数名> #与上同

```

```python
面向对象三大特征：
    封装 ：封装类的属性和方法，提高安全性，类内结构自由修改，减少耦合性，无视类中流程
         - 无私有属性修饰符，以前边使用'__'表示该属性不被类对象外部访问
         - 若强行使用该属性，则以 <实例对象>._<类对象名>__<私有属性名> 进行访问

    继承 ：父类->子类，提高复用性
         - class 子类类名(父类类名1，父类类名2…) 【py支持多继承】
         - 无父类默认继承object类
         - 定义子类需要在构造函数（__init__）中调用父类的构造函数
         - 在构造函数中，以super().来调用父类构造函数，并先运行父类
         - 子类可用父类定义的方法/属性
         - 父类方法子类重写：
                - 重写父类方法名，并先用super().调用父类该方法，
                - 该方法重写，不影响父类方法，仅在子类实例对象中生效

    多态 ：实例对象、方法、属性由程序中决定，提高可扩展性和维护性【鸭子类型】
          - 在不同类中重写同名不同内容的方法，在外部此方法名只跟实例对象有关【动态】
         - 静态语言【强类型语言】实现多态(C++，java，C#，即编译语言)：
                - 继承
                - 方法重写
                - 父类引用指向子类对象
         - 动态语言【弱类型语言】：
                - 只关注对象行为不关注对象本身(Python,PHP,JS,Ruby,即解释语言)

object类 【最大的父类】：
    特殊属性：
        __dict__ : 获得类对象的所有类属性和方法/实例对象的所有实例属性和方法【结果为字典】
        __class__ : 实例对象所属于的类
        __base__ : （类属性）实例对象所继承的第一个父类【加s为所有父类，结果为元组】       
        __mro__ : （类属性）包括该类和object类，加上所有继承的父类【结果为元组】
        __subclasses__ : （类属性）继承该类的所有子类【结果为列表】                   
    特殊方法：
        __len__() : 对象属性不可查长度，通过重写，让len()函数的参数可以为自定义类型
                    （len函数实质是调用该方法）      
        __add__() : 不同对象属性不可相加，通过重写，让自定义对象具有+功能
                    （+的实质是调用该方法）
        __new__() : 创建对象【此方法运行完后才生成实例对象】                   
        __init__() : 构造函数，将创建的对象实例化
        __main__() : 类的实例对象本身
        __str__() : 默认实例对象变量对应为地址，通过重写，改变对实例对象变量的描述

  stu = Student('Jack',20)
  print(stu)  --->  默认调用__str__()方法
                    打印为<__main__.Student object at (内存地址)>
      【若通过def __str__(self): return 重写默认调用的__str__】
  print(stu)  --->  打印为return返回的内容
                    【重写类方法，以return返回】

```

```python
类的拷贝：
    变量赋值：
        - 实例对象赋值给另一个变量，相当于两个名字指向同一个实例对象的内存
    浅拷贝：
        - import copy
        - 用copy.copy(obj)对一个实例对象进行拷贝成两份内存地址
        - 拷贝前后两个实例对象引用同一个子对象
    深拷贝：
        - import copy
        - 用copy.deepcopy(obj)对一个实例对象进行拷贝成两份内存地址
        - 递归拷贝将所有子对象拷贝成不同的内存，即两个实例对象引用两个相同但不是同一个的子对象
```

```python
三大结构第三方结构：模块>包>库
    import … 整个导入【可用as重命名】
    from … import … 单个【可用as重命名】/多个对象【以逗号隔开不同对象】导入
    from … import *    全部对象导入

模块：
    - 一个文件即一个模块，可运行模块中的函数、语句、对象、类
    - 提高可维护性和可重用性，避免变量名冲突
包：
    - 多个模块集合的一个目录，且必须有_init_.py文件
    - 避免模块重名
    - 导入时import <包名.模块名>/from <包名> import <模块名>【也可直接导入包】
库：
    - 具有相关功能的包和模块集合

if __name__ == '__main__' : 【不同模块运行时，检验模块名是否为顶级模块】

一个好玩的第三方库schedule
    import schedule
    def job():
        定义一个工作函数
    schedule.every(<数字，不写默认为1>).to(<前面数字到后面数字>).<时间单位>.at(<时间点>).do
    #every,<时间单位>,do必须有，别的可省略
    #<时间单位>为：seconds,minutes,hour,day,wednedday(星期数)
    #<时间点>为：字符串形式的24小时制

常用内置模块：
    · shutil ：复制和重命名操作
    · sys ：与python解释器和环境相关
        - sys.getsizeof(): 获取内存字节大小
        - 区别于os.path.getsize(path): 获取路径文件的内存字节大小
    · time ：时间相关【晶体振荡器计时】
    · calendar ：日期相关
    · urllib ：读取服务器【爬虫模块，通常用requests模块代替】
    · json : 对json类型文件进行处理（序列化和反序列化）
    · re ：正则表匹配与替换
    · math ：算术运算
    · decimal ：控制精准运算精度、有效数位、四舍五入【十进制操作】
    · logging
    · os ：访问操作系统功能

os模块：            (./ ：当前目录，等价于不写   ../ ：父级目录，此文件的上一级文件夹  / ：根目录)
    os.system()【系统自带】：notepad.exe（记事本）  calc.exe（计算器）  pause（暂停）
    目录操作函数(os.)：
        - walk(path)：遍历path路径的文件夹，返回为一个【迭代器对象】
        - getcwd()：返回当前工作目录
        - listdir(path)：返回path路径下文件和目录信息
        - mkdir(path[,mode])：创建目录/文件【mode为读、写、可执行权限】
        - makedirs(path1/path2…[,mode])：创建多级目录
        - rmdir(path)：删除目录
        - removedirs(path1/path2…)：删除多级目录
        - chdir(path)：将path路径设置为当前工作目录
    文件操作函数(os.)：
        - startfile(path)：打开path路径文件
        - remove()：删除文件
    os.path模块函数（也可直接用os进行使用该模块函数）：
        - exists()：检验是否存在
        - abspath(filename)：返回绝对路径
        - join(path，filename)：将上一级路径与文件名拼接为绝对路径
        - split(path)：将绝对路径中上一级路径与文件名拆开【join的逆操作】
        - splitext(filename)：将文件名与文件后缀拆分
        - basename(path)：从绝对路径提取文件名
        - dirname(path)：从绝对路径提取无文件后缀路径
        - isdir(path)：判断是否为无后缀名路径

删除文件夹及子目录：shutil.rmtee()（需要导入shutil内置库）
str.endwith()：判断字符串后缀名
```

```python
文件读写原理：
    - 队列储存，先进先出
    - 文件保存在磁盘，由解释器调用OS操作系统执行，对磁盘上文件进行读写
    - 从磁盘提取文件【读】，文件存入磁盘叫做【写】
    - 关闭调用资源
file = open(filename,[mode,encoding]) #mode默认只读，encoding默认于解释器有关
file.close #关闭文件

with open(filename,[mode,encoding]) as fp: #不需要关闭
    #with后接入内容，为上下文管理器，open语句执行时自动执行__enter__()【开头】和__exit__()【结尾】

打开模式：
    - r：只读，文件指针位于开头
    - w：只写，文件指针位于开头【不存在文件则创建，存在则覆盖】
    - a：追加，文件指针位于末尾【不存在文件则创建，存在则追加】
    - b：【不可单用】二进制打开 --- 【音频，图片，文档】
    - +：【不可单用】读写方式打开
文件操作方法：
    - read([size])：读取size个字节，size默认为全部字节
    - readline()：读取一行
    - readlines()：读取每一行，每一行以字符串形式，以列表返回
    - write(str)：将str字符串写入文件
    - writelines(lst)：将字符串列表写入文件，不添加换行【和readlines对应】
    - seek(off[,when])：文件指针移动off个字节（如果off不是数据类型所占字节的整数则报错）
                when为指针所在位置含义，0：指针在文件头，1：指针在当前位置，2：指针在文件尾【默认0】
    - tell()：从当前指针到结束一共的字节数
    - flush()：将缓冲区内容写入文件，且不关闭【close则关闭】
```




