# 基本算法思想

### 1.二分：O(logn)

#### 二分查找【有序数列】

#### 二分拓展------->以二分法进行数值逼近，或求单调函数的解

### 2.递归：O(n)

### 3.分治：O(nlogn)

#### 先二分到每个小部分 --- 在每个小部分进行操作 --- 再合起来治理统计

### 4.贪心：局部最优推出全局最优（无法举出反例）

#### 最多区间不相交问题/区间取点问题



# 排序入门

### 1.冒泡排序：O(n^2)

### 2.选择排序：O(n^2)

### 3.插入排序：O(n^2)

### 4.哈希排序（哈希/散列表）：O(1)

#### key通过H(key)【散列函数】转化为哈希值【散列值】，以哈希值作为下标进行数组存储

#### 哈希冲突：一个哈希值对应多个key，而key和哈希值应满足一对一映射关系

### 7.双指针思想（two pointers）

#### 即线性结构以两个下标（或指针）进行同时运动，减少运算时间

#### 运用：判断单调数组某两个数之和为M的个数（头尾指针）/快速排序/归并排序

### 8.归并排序：O(nlogn)

#### 即运用二分+递归+分治，将需要排序的二分到个数，再进行分治-双指针有序合并

### 9.快速排序：O(nlogn)

#### 即运用二分+递归+分治，将需要排序的二分到个数，再进行分治-处理，从局部排序到整体

#### 归并采用双指针有序合并，快排采用双指针基准数交换，一般采用最左端为基准数，以基准数为标准，将两端右边值小于左边值交换（小->大），直到双指针重合

### 10.随机快速排序：O(nlogn)

#### 在快排的基础上，总以最左边为基准数效率不高，基准数为列表中随机一个数效率最高

#### 改进：用生成伪随机数作为每一次的基准数（random）

### 11.随机选择算法：O(n)

#### 【无序序列中，查询第K大的数】

#### 类似于【随即快排】，当基准数为A[p]，双指针交换排序后，则A[p]为第p-left+1大的数

#### ①K==p-left+1：则A[p]即为第K大的数，终止查询

#### ②K<p-left+1：则第K大的数在A[p]左侧（反之亦然）【类似于二分查找】

###### 二分查找：有序数列中查找值为K的位置			随机选择算法：无序数列中查找第K大的值





# 简单的算法

### 		1.秦九韶多项式：

#### 						f(x)=a0+a1*x+…+a(n-1)*x^(n-1)+an*x^n	a0-an为有规律的数列，1-x^n为等比数列

#### 						==>  f(x)=a0+x(a1+x(a2+x(…x(a(n-1)+x(an))))

### 2.快速幂/二分幂：O(logN)

#### 幂数为奇：总和×一个底数，指数-1

#### 幂数为偶：底数变为平方，指数/2

#### 直到b>0循环结束

### 3.埃氏筛法：O(nloglogn)

###### 普通筛法：O(sqrt(n))【适用n^5以内】		埃氏筛法：O(nloglogn)【适用于n^7以内】	欧拉筛法（线性筛）

#### 一个数组判定标记是否为素数，初始化全为true

#### 筛选2~n的所有素数，未被筛去则为素数，将后续该素数倍数false

#### 缺点：部分合数被多次判定为false浪费时间 -----> 线性筛

### 4.欧拉筛法：

#### 埃氏筛法改进版：

#### 一个数组bool判定标记是否为素数，一个数组存储素数，一个整数记录素数个数

#### 埃氏筛：遍历后续判定数组，判定素数倍数都为false

#### 欧拉筛：

#### ①遍历存储素数的数组，某数组元素×该判定数=M，若M<n，则判定数组M为false       

###### （ 判定已有素数表中，所有素数的该判定数倍为false【若该判定数为true则是已有全部素数】 )

#### ②该判定数%某数组元素=N，若N==0，则break素数数组的遍历【这一步即埃氏筛改进】

###### （ 若某一素数为该判定数质因子，则跳出循环，避免多次判定false )



# 简单数学问题

### 			1.高精度：【通常以结构体存储每位数的数组和数组长度】

#### 高精度+高精度：按位相加，过10进一，超过最长数组后若进位不为零则补在更高一位

#### 高精度-高精度：大-小，按位相减，不够加10，高位-1

###### 注意排除最高位为0和得数为0 ---> 即保证在长度>0的条件下，最高位为0则长度-1【依次递推】

#### 高精度×低精度：将低精度视为一个整体，与每个数组相乘，过10进一

###### 遍历完整个数组，可能进位不为零，单独处理以增加数组长度

#### 高精度÷低精度：被除数位数与商位数相同，不够除则商值为0，余数×10+下一位

##### 【都是整形相除，结果可能有余数，若无余数以0表示】

###### 注意排除最高位为0和得数为0 ---> 即保证在长度>0的条件下，最高位为0则长度-1【依次递推】

### 2.欧几里得拓展  --->  ax+by = c

#### ax+by = c 存在解的充要条件：c%gcd==0

#### ax+by = c 中，x，y分别以b/gcd和a/gcd为周期（一加一减）

### 3.阶乘 n! 中有多少个质因子p：O(logn)

###### （判断 n! 末尾有多少个0，即有多少个质因子p==5）

#### n!中质因子数== {n/p + n/p^2 + n/p^3…} 【整除向下取整，直到n/p^k < p】

### 4.组合数C（n，m）【n>=m】

#### 模型：C(n,m) = n!/[m!*(n-m)!] = (n-m+1)(n-m+2)…(n-m+m)/(1+2+…+m)

#### ① C(n,m) = C(n-1,m) + C(n-1,m-1)	【基底：C(m,m)==C(n,0)==1】 

#### ② C(n,m) = (n-m+1)/1 * (n-m+2)/2*…(n-m+m)/m	【 i 的范围为1-m】

###### （ ② 以循环/递归实现，n=67/m=33时溢出，以高精度存储）		O(m)

### 5.计算 C(n,m)%p

#### ① 质因子分解：分解质因子pi，由模型一得，n!  m!  (n-m)!的pi指数分别为x y z，则C(n,m)分解为 pi^(x-y-z) 【x-y-z>0】，用快速幂计算并%p

#### ②卢卡斯定理：唯一条件 -- p为素数 【直接背代码吧，理解不了……】

![image-20230418220315117](C:\Users\86180\AppData\Roaming\Typora\typora-user-images\image-20230418220315117.png)

#### ③ 略了略了……太他妈难了……